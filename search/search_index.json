{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>My library of custom python scripts and configurations.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Custom matplotlib plotting styles and colors</li> <li>A run logger for logging training runs in Machine/Deep learning pipelines</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install using pip, run:</p> <pre><code>pip install iragca\n</code></pre> <p>Only install the matplotlib scripts</p> <pre><code>pip install iragca[matplotlib]\n</code></pre>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code>import matplotlib.pyplot as plt\n\nfrom iragca.matplotlib import Color, Styles\n\nplt.style.use(Styles.CMR10.value)\n\nsample_data = [1, 3, 2, 4, 3, 5]\n\nplt.plot(sample_data, color=Color.BLUE.value)\nplt.title(\"Sample Plot with Custom Style and Color\")\nplt.xlabel(\"X-axis\")\nplt.ylabel(\"Y-axis\")\nplt.show()\n</code></pre>"},{"location":"RunLogger/","title":"RunLogger","text":"<p>A lightweight logger for tracking scalar metrics across sequential steps.</p> <p>This class provides:</p> <ul> <li>Metric logging for arbitrary named metrics.</li> <li>Dynamic attribute access, e.g., <code>logger.loss</code> \u2192 list of all logged loss values.</li> <li>Optional tqdm progress bar display, with support for both console and Jupyter Notebook environments.</li> </ul> Example usage <pre><code>from iragca.ml import RunLogger\n\nlogger = RunLogger(max_steps=100, display_progress=True)\nfor epoch in range(100):\n    # Simulate logging metrics\n    logger.log_metrics({'loss': 1.035, 'accuracy': 0.7728}, step=epoch)\n\nprint(logger.loss)                #  Access logged loss values\n# [10.0, 9.9, 9.8, ..., 0.1]\nprint(logger.accuracy)            #  Access logged accuracy values\n# [0.0, 0.01, 0.02, ..., 0.99]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>max_steps</code> <code>int</code> <p>Total number of expected steps. Used for progress bar display.</p> <code>Field(..., ge=1)</code> <code>display_progress</code> <code>bool</code> <p>If True, a tqdm progress bar is shown during logging.</p> <code>Field(False)</code> <code>update_interval</code> <code>int</code> <p>Frequency (in steps) to update the progress bar. Default is 1 (update every step).</p> <code>Field(1, ge=1)</code> <code>notebook</code> <code>bool</code> <p>Whether to use <code>tqdm.notebook.tqdm</code> or <code>tqdm.tqdm</code>.</p> <code>Field(False)</code> <code>tqdm_kwargs</code> <code>dict</code> <p>Key word arguments for <code>tqdm.tqdm</code></p> <code>Field({})</code> Source code in <code>iragca/ml/runlogger.py</code> <pre><code>@validate_call\ndef __init__(\n    self,\n    max_steps: int = Field(..., ge=1),\n    display_progress: bool = Field(False),\n    update_interval: int = Field(1, ge=1),\n    notebook: bool = Field(False),\n    tqdm_kwargs: dict = Field({}),\n):\n    \"\"\"\n    Parameters\n    ----------\n    max_steps : int\n        Total number of expected steps. Used for progress bar display.\n    display_progress : bool, optional\n        If True, a tqdm progress bar is shown during logging.\n    update_interval : int, optional\n        Frequency (in steps) to update the progress bar. Default is 1 (update every step).\n    notebook : bool, optional\n        Whether to use `tqdm.notebook.tqdm` or `tqdm.tqdm`.\n    tqdm_kwargs : dict\n        Key word arguments for `tqdm.tqdm`\n    \"\"\"\n    self.history = {}\n    self._display_progress = display_progress\n    self._max_steps = max_steps\n    self.tqdm_kwargs = tqdm_kwargs\n    self._notebook = notebook\n\n    if self._display_progress:\n        self._update_interval = update_interval\n        self.pbar = (\n            nbtqdm(total=max_steps, **self.tqdm_kwargs)\n            if notebook\n            else tqdm(total=max_steps, **self.tqdm_kwargs)\n        )\n</code></pre>"},{"location":"RunLogger/#iragca.ml.RunLogger.metrics","title":"<code>metrics</code>  <code>property</code>","text":"<p>List[str]     List of all logged metric names.</p>"},{"location":"RunLogger/#iragca.ml.RunLogger.steps","title":"<code>steps</code>  <code>property</code>","text":"<p>List[int]     Sorted list of recorded step indices.</p>"},{"location":"RunLogger/#iragca.ml.RunLogger.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Fallback attribute access for dynamic metric lookup.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Metric name being accessed.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of values for the metric across all steps.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the metric does not exist.</p> Source code in <code>iragca/ml/runlogger.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"\n    Fallback attribute access for dynamic metric lookup.\n\n    Parameters\n    ----------\n    name : str\n        Metric name being accessed.\n\n    Returns\n    -------\n    list\n        List of values for the metric across all steps.\n\n    Raises\n    ------\n    AttributeError\n        If the metric does not exist.\n    \"\"\"\n    if self.history:\n        steps = sorted(self.history.keys())\n        if name in self.history[steps[0]]:\n            return [self.history[s].get(name) for s in steps]\n\n    raise AttributeError(f\"{name!r} not found in RunLogger.\")\n</code></pre>"},{"location":"RunLogger/#iragca.ml.RunLogger.add_metric_property","title":"<code>add_metric_property(metric_name)</code>","text":"<p>Dynamically create a read-only property for accessing metric history.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name of the metric to expose as a property.</p> required Notes <p>After logging <code>loss</code>, you can access it via <code>logger.loss</code>.</p> Source code in <code>iragca/ml/runlogger.py</code> <pre><code>def add_metric_property(self, metric_name: str):\n    \"\"\"\n    Dynamically create a read-only property for accessing metric history.\n\n    Parameters\n    ----------\n    metric_name : str\n        Name of the metric to expose as a property.\n\n    Notes\n    -----\n    After logging ``loss``, you can access it via ``logger.loss``.\n    \"\"\"\n    if hasattr(self, metric_name):\n        raise AttributeError(f\"Attribute {metric_name!r} already exists.\")\n\n    def getter(self):\n        if not self.history:\n            return []\n        return [self.history[step].get(metric_name) for step in sorted(self.history.keys())]\n\n    setattr(self.__class__, metric_name, property(getter))\n</code></pre>"},{"location":"RunLogger/#iragca.ml.RunLogger.from_dict","title":"<code>from_dict(logs)</code>  <code>classmethod</code>","text":"<p>Create a RunLogger instance from existing logs or dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>logs</code> <code>dict</code> <p>Dictionary of the form::</p> <pre><code>{\n    \"step\": [...],\n    \"metric_name_1\": [...],\n    \"metric_name_2\": [...],\n    ...\n}\n</code></pre> required <p>Returns:</p> Type Description <code>RunLogger</code> <p>Instance populated with the provided logs.</p> Notes <p>This is the inverse of the <code>get_logs</code> method. 'step' key is required in the input dictionary.</p> Source code in <code>iragca/ml/runlogger.py</code> <pre><code>@classmethod\ndef from_dict(cls, logs: dict) -&gt; \"RunLogger\":\n    \"\"\"\n    Create a RunLogger instance from existing logs or dictionary.\n\n    Parameters\n    ----------\n    logs : dict\n        Dictionary of the form::\n\n            {\n                \"step\": [...],\n                \"metric_name_1\": [...],\n                \"metric_name_2\": [...],\n                ...\n            }\n\n    Returns\n    -------\n    RunLogger\n        Instance populated with the provided logs.\n\n    Notes\n    -----\n    This is the inverse of the `get_logs` method.\n    'step' key is required in the input dictionary.\n    \"\"\"\n    max_steps = len(logs.get(\"step\", []))\n    logger = cls(max_steps=max_steps)\n\n    for i, step in enumerate(logs.get(\"step\", [])):\n        log_data = {key: logs[key][i] for key in logs.keys() if key != \"step\"}\n        logger.log_metrics(log_data, step)\n\n    return logger\n</code></pre>"},{"location":"RunLogger/#iragca.ml.RunLogger.get_logs","title":"<code>get_logs()</code>","text":"<p>Return all logged metrics organized by step.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of the form::</p> <pre><code>{\n    \"step\": [...],\n    \"metric_name_1\": [...],\n    \"metric_name_2\": [...],\n    ...\n}\n</code></pre> <p>If no logs are recorded, returns::</p> <pre><code>{\n    \"step\": [],\n    \"metrics\": {}\n}\n</code></pre> Source code in <code>iragca/ml/runlogger.py</code> <pre><code>def get_logs(self) -&gt; dict:\n    \"\"\"\n    Return all logged metrics organized by step.\n\n    Returns\n    -------\n    dict\n        Dictionary of the form::\n\n            {\n                \"step\": [...],\n                \"metric_name_1\": [...],\n                \"metric_name_2\": [...],\n                ...\n            }\n\n        If no logs are recorded, returns::\n\n            {\n                \"step\": [],\n                \"metrics\": {}\n            }\n    \"\"\"\n    if not self.history:\n        return {\"step\": [], \"metrics\": {}}\n\n    steps = sorted(self.history.keys())\n    first_step = steps[0]\n\n    return {\n        \"step\": steps,\n        **{\n            key: [self.history[step].get(key) for step in steps]\n            for key in self.history[first_step].keys()\n        },\n    }\n</code></pre>"},{"location":"RunLogger/#iragca.ml.RunLogger.log_metrics","title":"<code>log_metrics(log_data, step)</code>","text":"<p>Log one or more metrics for a given step.</p> <p>Parameters:</p> Name Type Description Default <code>log_data</code> <code>dict</code> <p>Dictionary mapping metric names to numeric values.</p> required <code>step</code> <code>int</code> <p>Index of the current step (e.g., epoch or iteration).</p> required Notes <ul> <li>If metrics already exist for a step, new values will update or   extend the existing dictionary.</li> <li>New metric names automatically become accessible as properties,   e.g., <code>logger.accuracy</code> returns a list of accuracy values.</li> </ul> Source code in <code>iragca/ml/runlogger.py</code> <pre><code>def log_metrics(self, log_data: dict, step: int):\n    \"\"\"\n    Log one or more metrics for a given step.\n\n    Parameters\n    ----------\n    log_data : dict\n        Dictionary mapping metric names to numeric values.\n    step : int\n        Index of the current step (e.g., epoch or iteration).\n\n    Notes\n    -----\n    - If metrics already exist for a step, new values will update or\n      extend the existing dictionary.\n    - New metric names automatically become accessible as properties,\n      e.g., ``logger.accuracy`` returns a list of accuracy values.\n    \"\"\"\n    if step not in self.history:\n        self.history[step] = {}\n\n    # update metrics for this step\n    for key, value in log_data.items():\n        self.history[step][key] = value\n\n        # Create metric property lazily if not present\n        if not hasattr(self, key):\n            self.add_metric_property(key)\n\n    if not self._display_progress:\n        return\n\n    # update progress bar\n    self.pbar.update(1)\n    if step % self._update_interval == 0:\n        self.pbar.set_postfix(log_data, refresh=True)\n\n    if self.pbar.n == self._max_steps:\n        self.pbar.close()\n        self._display_progress = False\n</code></pre>"}]}